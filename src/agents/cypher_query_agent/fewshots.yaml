FEW_SHOTS_CYPHER_QUERY:
  - input: Total de proyectos
  - output: |
      /* total of projects */

      MATCH (p:Project)
      RETURN count(p) AS totalProjects
  - input: Total de regiones
  - output: |
      /* total of regions */

      MATCH (p:Project)-[IN_REGION]->(r:Region)
      RETURN count(DISTINCT r.name) AS totalRegions
  - input: Total de comunas
  - output: |
      /* total of communes */

      MATCH (c:Commune)
      RETURN count(c) AS total_communes
  - input: Total de tipos de proyecto
  - output: |
      /* total count of  project types */

      MATCH (p:Project)-[:HAS_PROJECT_TYPE]->(pt:ProjectType)
      RETURN count(DISTINCT pt) AS projectTypeCount

  - input: Nombres de los proyectos
  - output: |
      /* Nombres de los proyectos */

      MATCH (p:Project)
      RETURN p.name
  - input: Nombres de los tipos de proyecto
  - output: |
      MATCH (p:ProjectType)
      RETURN p.name
  - input: Nombres de las regiones con proyectos
  - output: |
      /* Nombres de las regiones con proyectos */

      MATCH (p:Project)-[IN_REGION]->(r:Region)
      RETURN DISTINCT r.name
  - input: Nombres de las comunas con proyectos
  - output: |
      /* Nombres de las comunas con proyectos */

      MATCH (p:Project)-[IN_COMMUNE]->(c:Commune)
      RETURN DISTINCT c.name
  - input: Total de proyectos por Región
  - output: |
      /* Total de proyectos por Región */

      MATCH (p:Project)-[IN_REGION]->(r:Region)
      RETURN r.name AS region, count(p) AS totalProjects
      ORDER BY totalProjects DESC
  - input: Total de proyectos por Tipo de Proyecto
  - output: |
      /* Total de proyectos por Tipo de Proyecto */

      MATCH (p:Project)-[HAS_PROJECT_TYPE]->(pt:ProjectType)
      RETURN pt.name AS TipoProyecto, count(p) AS TotalProyectos
  - input: Total de proyectos por Comuna
  - output: |
      /* Total de proyectos por Comuna */

      MATCH (p:Project)-[IN_COMMUNE]->(c:Commune)
      RETURN c.name AS commune, count(p) AS totalProjects
      ORDER BY totalProjects DESC
  - input: Total de proyectos por Tipología
  - output: |
      /* Total de proyectos por Tipología */

      MATCH (p:Project)-[r:HAS_TIPOLOGIA]->(t:Tipologia)
      RETURN t.code AS Tipologia, count(p) AS TotalProyectos
  - input: Total de proyectos presentados por mes
  - output: |
      /* Total de proyectos presentados por mes, show month and year */

      MATCH (p:Project)-[r:PRESENTED_ON]->(d:PresentationDate)
      RETURN date(d.date).month AS month, date(d.date).year AS year, count(p) AS totalProjects
      ORDER BY year, month

  - input: nombre de los proyectos presentados en enero de 2023, muestra su fecha de presentación
  - output: |
      /* nombre de los proyectos presentados en enero de 2023, muestra su fecha de presentación */

      MATCH (p:Project)-[r:PRESENTED_ON]->(d:PresentationDate)
      WHERE d.date >= date('2023-01-01') AND d.date < date('2023-02-01')
      RETURN p.name AS project_name, d.date AS presentation_date

  - input: nombre de los proyectos presentados en mayo de 2022, muestra su fecha de presentación
  - output: |
      /* nombre de los proyectos presentados en mayo de 2022, muestra su fecha de presentación */

      MATCH (p:Project)-[pr:PRESENTED_ON]->(d:PresentationDate)
      WHERE d.date >= date('2022-05-01') AND d.date < date('2022-06-01')
      RETURN p.name AS nombre_proyecto, d.date AS fecha_presentacion

  - input: que comunas hay en los documentos?
  - output: |
      // Selecciona todas las comunas en el grafo
      MATCH (c:Commune)
      // Agrega nombres únicos y el total de comunas distintas
      WITH collect(DISTINCT c.name) AS names, count(DISTINCT c) AS total
      // Convierte la lista de nombres a filas
      UNWIND names AS commune
      // Devuelve el nombre de comuna y el total (constante por fila)
      RETURN commune, total
      // Ordena alfabéticamente por comuna
      ORDER BY commune

  - input: Cuantos proyectos hay?
  - output: |
      // Selecciona todos los proyectos
      MATCH (p:Project)
      // Agrega nombres únicos de proyectos y total de proyectos distintos
      WITH collect(DISTINCT p.name) AS names, count(DISTINCT p) AS total
      // Convierte la lista de nombres a filas
      UNWIND names AS project
      // Devuelve el nombre del proyecto y el total (constante por fila)
      RETURN project, total
      // Ordena alfabéticamente por nombre de proyecto
      ORDER BY project

  - input: Obtener los nombres de las comunas y su conteo total
  - output: |
      // Selecciona proyectos y sus comunas asociadas
      MATCH (p:Project)-[:IN_COMMUNE]->(c:Commune)
      // Agrega nombres únicos de comuna y total de comunas distintas
      WITH collect(DISTINCT c.name) AS names, count(DISTINCT c) AS total
      // Convierte la lista a filas
      UNWIND names AS commune
      // Devuelve la comuna y el total (constante por fila)
      RETURN commune, total
      // Ordena por comuna
      ORDER BY commune

  - input: Nombres y conteo total de regiones que tienen proyectos
  - output: |
      // Selecciona proyectos y sus regiones asociadas
      MATCH (p:Project)-[:IN_REGION]->(r:Region)
      // Agrega nombres únicos de región y total de regiones distintas
      WITH collect(DISTINCT r.name) AS names, count(DISTINCT r) AS total
      // Convierte la lista a filas
      UNWIND names AS region
      // Devuelve la región y el total (constante por fila)
      RETURN region, total
      // Ordena alfabéticamente por región
      ORDER BY region

  - input: Dame la fecha de presentación de los proyectos
  - output: |
      // Vincula proyectos con su fecha de presentación
      MATCH (p:Project)-[:PRESENTED_ON]->(d:PresentationDate)
      // Devuelve nombre, id y la fecha
      RETURN p.name AS project, p.id AS id, d.date AS presentationDate
      // Ordena desde la fecha más reciente y luego por nombre
      ORDER BY d.date DESC, project

  - input: dame los proyectos tipología c, y subtipo anexes
  - output: |
      // Filtra proyectos con tipología 'c'
      MATCH (p:Project)-[:HAS_TIPOLOGIA]->(:Tipologia {code:'c'})
      // Y con subtipo documental 'anexes'
      MATCH (p)-[:HAS_DOCUMENT_SUBTYPE]->(:DocumentSubtype {name:'anexes'})
      // Devuelve proyectos únicos con su id
      RETURN DISTINCT p.name AS project, p.id AS id
      // Ordena por nombre de proyecto
      ORDER BY project

  - input: proyectos en las comunas Antofagasta o Mejillones
  - output: |
      // Selecciona proyectos ubicados en comunas
      MATCH (p:Project)-[:IN_COMMUNE]->(c:Commune)
      // Filtra por las comunas objetivo
      WHERE c.name IN ['Antofagasta','Mejillones']
      // Devuelve proyectos únicos y su id
      RETURN DISTINCT p.name AS project, p.id AS id
      // Ordena por nombre
      ORDER BY project

  - input: proyectos en la Región de Antofagasta
  - output: |
      // Selecciona proyectos en la región de Antofagasta
      MATCH (p:Project)-[:IN_REGION]->(:Region {name:'Región de Antofagasta'})
      // Devuelve proyectos únicos
      RETURN DISTINCT p.name AS project
      // Ordena por nombre de proyecto
      ORDER BY project

  - input: proyectos por tipo 'Centrales generadoras de energía mayores a 3 MW'
  - output: |
      // Proyectos con tipo específico (centrales > 3 MW)
      MATCH (p:Project)-[:HAS_PROJECT_TYPE]->(:ProjectType {name:'Centrales generadoras de energía mayores a 3 MW'})
      // Devuelve proyectos únicos
      RETURN DISTINCT p.name AS project
      // Ordena por nombre
      ORDER BY project

  - input: proyectos por tipología c
  - output: |
      // Proyectos con tipología 'c'
      MATCH (p:Project)-[:HAS_TIPOLOGIA]->(:Tipologia {code:'c'})
      // Devuelve proyectos únicos
      RETURN DISTINCT p.name AS project
      // Ordena por nombre
      ORDER BY project

  - input: proyectos con fecha de presentación desde 2018-01-01
  - output: |
      // Proyectos y su fecha de presentación
      MATCH (p:Project)-[:PRESENTED_ON]->(d:PresentationDate)
      // Filtra desde 2018-01-01 (incluido)
      WHERE date(d.date) >= date('2018-01-01')
      // Devuelve proyecto y fecha normalizada a tipo date
      RETURN DISTINCT p.name AS project, date(d.date) AS presentationDate
      // Ordena por fecha (desc) y nombre
      ORDER BY presentationDate DESC, project

  - input: proyectos por subtype anexes
  - output: |
      // Proyectos con subtipo documental 'anexes'
      MATCH (p:Project)-[:HAS_DOCUMENT_SUBTYPE]->(:DocumentSubtype {name:'anexes'})
      // Devuelve proyectos únicos
      RETURN DISTINCT p.name AS project
      // Ordena por nombre
      ORDER BY project

  - input: proyectos en Antofagasta o Mejillones en Región de Antofagasta y tipo específico desde 2018
  - output: |
      // Punto de partida: todos los proyectos
      MATCH (p:Project)
      // En la Región de Antofagasta
      MATCH (p)-[:IN_REGION]->(:Region {name:'Región de Antofagasta'})
      // En comunas específicas
      MATCH (p)-[:IN_COMMUNE]->(c:Commune)
      WHERE c.name IN ['Antofagasta','Mejillones']
      // Del tipo de proyecto requerido
      MATCH (p)-[:HAS_PROJECT_TYPE]->(:ProjectType {name:'Centrales generadoras de energía mayores a 3 MW'})
      // Con fecha de presentación en rango
      MATCH (p)-[:PRESENTED_ON]->(d:PresentationDate)
      WHERE date(d.date) >= date('2018-01-01') AND date(d.date) <= date('2025-12-31')
      // Devuelve proyecto, id y fecha normalizada
      RETURN DISTINCT p.name AS project, p.id AS id, date(d.date) AS presentationDate
      // Ordena por fecha (desc) y nombre
      ORDER BY presentationDate DESC, project

  - input: conteo de proyectos por comuna
  - output: |
      // Cuenta proyectos por comuna
      MATCH (p:Project)-[:IN_COMMUNE]->(c:Commune)
      RETURN c.name AS commune, count(DISTINCT p) AS projects
      // Ordena por mayor cantidad y luego por nombre
      ORDER BY projects DESC, commune

  - input: comunas por región (lista de comunas por región)
  - output: |
      // Vincula proyectos con región y comuna
      MATCH (p:Project)-[:IN_REGION]->(r:Region)
      MATCH (p)-[:IN_COMMUNE]->(c:Commune)
      // Junta comunas únicas por región
      WITH r.name AS region, collect(DISTINCT c.name) AS names
      // Convierte a filas para ordenar alfabéticamente
      UNWIND names AS name
      WITH region, name
      ORDER BY name
      // Reconstruye la lista ordenada por región
      WITH region, collect(name) AS communes
      RETURN region, communes
      // Ordena por región
      ORDER BY region

  - input: conteo de proyectos por tipología
  - output: |
      // Cuenta proyectos por código de tipología
      MATCH (p:Project)-[:HAS_TIPOLOGIA]->(t:Tipologia)
      RETURN t.code AS tipologia, count(DISTINCT p) AS projects
      // Ordena por mayor cantidad y luego por código
      ORDER BY projects DESC, tipologia

  - input: conteo de proyectos por tipo de proyecto
  - output: |
      // Cuenta proyectos por tipo de proyecto
      MATCH (p:Project)-[:HAS_PROJECT_TYPE]->(pt:ProjectType)
      RETURN pt.name AS projectType, count(DISTINCT p) AS projects
      // Ordena por mayor cantidad y luego por nombre del tipo
      ORDER BY projects DESC, projectType

  - input: proyectos con más de una comuna
  - output: |
      // Detecta proyectos que abarcan más de una comuna
      MATCH (p:Project)-[:IN_COMMUNE]->(c:Commune)
      WITH p, count(DISTINCT c) AS communes
      WHERE communes > 1
      RETURN p.name AS project, p.id AS id, communes
      // Ordena por mayor número de comunas y luego por nombre
      ORDER BY communes DESC, project

  - input: último proyecto por comuna
  - output: |
      // Para cada comuna, encontrar el proyecto más reciente
      MATCH (p:Project)-[:IN_COMMUNE]->(c:Commune)
      MATCH (p)-[:PRESENTED_ON]->(d:PresentationDate)
      // Proyecta la fecha como tipo date y conserva el proyecto
      WITH c.name AS commune, p, date(d.date) AS date
      // Ordena por fecha descendente para que el primero sea el más reciente
      ORDER BY date DESC
      // Agrupa por comuna y empaqueta los proyectos con su metadata
      WITH commune, collect({project:p.name, id:p.id, date:date}) AS projects
      // Toma el primero de la lista (más reciente)
      RETURN commune, projects[0] AS latest
      // Ordena por nombre de comuna
      ORDER BY commune

  - input: proyectos tipología c y subtype anexes
  - output: |
      // Tipología 'c' y subtipo 'anexes'
      MATCH (p:Project)-[:HAS_TIPOLOGIA]->(:Tipologia {code:'c'})
      MATCH (p)-[:HAS_DOCUMENT_SUBTYPE]->(:DocumentSubtype {name:'anexes'})
      // Devuelve proyectos únicos
      RETURN DISTINCT p.name AS project
      // Ordena por nombre
      ORDER BY project

  - input: conteo mensual de proyectos
  - output: |
      // Proyectos con su fecha de presentación
      MATCH (p:Project)-[:PRESENTED_ON]->(d:PresentationDate)
      // Normaliza a tipo date y conserva p para el conteo
      WITH date(d.date) AS dd, p
      // Agrupa por mes (primer día del mes) y cuenta proyectos únicos
      WITH date({year: dd.year, month: dd.month, day: 1}) AS month, count(DISTINCT p) AS num
      // Devuelve mes y conteo
      RETURN month, num
      // Orden cronológico por mes
      ORDER BY month

  - input: proyectos por DocumentType 'ei-document'
  - output: |
      // Filtra proyectos con DocumentType 'ei-document'
      MATCH (p:Project)-[:HAS_DOCUMENT_TYPE]->(:DocumentType {name:'ei-document'})
      // Calcula total y prepara una lista de nombres únicos
      WITH count(DISTINCT p) AS total, collect(DISTINCT p.name) AS names
      // Convierte la lista a filas para ordenar alfabéticamente
      UNWIND names AS name
      WITH total, name
      ORDER BY name
      // Reconstruye la lista ya ordenada
      WITH total, collect(name) AS projects
      // Devuelve total y lista de proyectos ordenada
      RETURN total, projects

  - input: proyectos en lista de comunas usando WITH
  - output: |
      // Define la lista de comunas objetivo en el scope
      WITH ['Antofagasta','Mejillones'] AS targetCommunes
      // Selecciona proyectos en comunas
      MATCH (p:Project)-[:IN_COMMUNE]->(c:Commune)
      // Filtra por esa lista
      WHERE c.name IN targetCommunes
      // Devuelve proyectos únicos
      RETURN DISTINCT p.name AS project
      // Ordena por nombre
      ORDER BY project

  - input: proyectos sin tipología asignada
  - output: |
      // Proyectos que no tienen ninguna tipología asociada
      MATCH (p:Project)
      WHERE NOT (p)-[:HAS_TIPOLOGIA]->(:Tipologia)
      // Devuelve sus nombres
      RETURN p.name AS project
      // Ordena por nombre
      ORDER BY project

  - input: proyectos en Región de Antofagasta excluyendo la comuna Antofagasta
  - output: |
      // Proyectos en la región objetivo
      MATCH (p:Project)-[:IN_REGION]->(:Region {name:'Región de Antofagasta'})
      // Excluye los que están en la comuna Antofagasta
      WHERE NOT EXISTS { MATCH (p)-[:IN_COMMUNE]->(:Commune {name:'Antofagasta'}) }
      // Devuelve proyectos únicos
      RETURN DISTINCT p.name AS project
      // Ordena por nombre
      ORDER BY project

  - input: proyecto más antiguo y más reciente
  - output: |
      // Vincula proyectos con su fecha de presentación
      MATCH (p:Project)-[:PRESENTED_ON]->(d:PresentationDate)
      // Proyecta el nombre y normaliza la fecha
      WITH p.name AS project, date(d.date) AS date
      // Ordena ascendente para que el primero sea el más antiguo
      ORDER BY date ASC
      // Colecciona pares (proyecto, fecha)
      WITH collect({project: project, date: date}) AS pairs
      // Devuelve el primer y el último elemento (más antiguo y más reciente)
      RETURN pairs[0] AS earliest, pairs[-1] AS latest

  - input: proyectos por región y tipo con conteo
  - output: |
      // Cruza región y tipo de proyecto y cuenta proyectos
      MATCH (p:Project)-[:IN_REGION]->(r:Region)
      MATCH (p)-[:HAS_PROJECT_TYPE]->(pt:ProjectType)
      RETURN r.name AS region, pt.name AS projectType, count(DISTINCT p) AS projects
      // Ordena por región y, dentro, por mayor cantidad
      ORDER BY region, projects DESC

  - input: proyectos que contienen todas las comunas requeridas (Antofagasta y Mejillones)
  - output: |
      // Lista de comunas que el proyecto debe tener
      WITH ['Antofagasta','Mejillones'] AS mustHave
      // Selecciona proyectos y sus comunas
      MATCH (p:Project)-[:IN_COMMUNE]->(c:Commune)
      // Se queda sólo con filas en comunas de interés
      WHERE c.name IN mustHave
      // Junta las comunas del proyecto y lleva mustHave a través del WITH
      WITH p, collect(DISTINCT c.name) AS pc, mustHave
      // Asegura que todas las comunas requeridas están en las del proyecto
      WHERE ALL(x IN mustHave WHERE x IN pc)
      // Devuelve el proyecto
      RETURN p.name AS project
      // Ordena por nombre
      ORDER BY project

  - input: proyectos entre 2015 y 2020 (inclusive)
  - output: |
      // Cuenta proyectos presentados entre 2015 y 2020 inclusive
      MATCH (p:Project)-[:PRESENTED_ON]->(d:PresentationDate)
      WHERE date(d.date) >= date('2015-01-01') AND date(d.date) <= date('2020-12-31')
      RETURN count(DISTINCT p) AS total

  - input: proyectos por año de presentación (conteo)
  - output: |
      // Conteo anual de proyectos
      MATCH (p:Project)-[:PRESENTED_ON]->(d:PresentationDate)
      // Normaliza fecha y lleva p para contar
      WITH date(d.date) AS dd, p
      // Devuelve año y número de proyectos únicos
      RETURN dd.year AS year, count(DISTINCT p) AS projects
      // Ordena por año
      ORDER BY year

  - input: resumen por región (total proyectos, primera y última fecha)
  - output: |
      // Resumen por región: total proyectos, primera y última fecha
      MATCH (p:Project)-[:IN_REGION]->(r:Region)
      OPTIONAL MATCH (p)-[:PRESENTED_ON]->(d:PresentationDate)
      WITH r.name AS region, count(DISTINCT p) AS projects,
          min(date(d.date)) AS earliest, max(date(d.date)) AS latest
      RETURN region, projects, earliest, latest
      // Ordena por región
      ORDER BY region

  - input: proyectos con y sin tipología (flag)
  - output: |
      // Marca si cada proyecto tiene alguna tipología
      MATCH (p:Project)
      WITH p, EXISTS { MATCH (p)-[:HAS_TIPOLOGIA]->(:Tipologia) } AS hasTipologia
      RETURN p.name AS project, CASE WHEN hasTipologia THEN 'Sí' ELSE 'No' END AS tieneTipologia
      // Ordena por nombre
      ORDER BY project

  - input: pares de proyectos que comparten comuna o región (muestra)
  - output: |
      // Encuentra pares de proyectos que comparten comuna o región
      MATCH (p1:Project)-[:IN_COMMUNE|IN_REGION]->()<-[:IN_COMMUNE|IN_REGION]-(p2:Project)
      // Evita duplicados de pares imponiendo un orden por elementId
      WHERE elementId(p1) < elementId(p2)
      // Devuelve los nombres de ambos proyectos
      RETURN p1.name AS project1, p2.name AS project2
      // Ordena para lectura
      ORDER BY project1, project2
      // Limita a una muestra
      LIMIT 10

  - input: proyectos por comuna con lista de proyectos
  - output: |
      // Lista de proyectos por comuna
      MATCH (p:Project)-[:IN_COMMUNE]->(c:Commune)
      // Colecciona nombres únicos de proyectos por comuna
      WITH c.name AS commune, collect(DISTINCT p.name) AS names
      // Convierte a filas para ordenar por comuna y nombre
      UNWIND names AS name
      WITH commune, name
      ORDER BY commune, name
      // Reconstruye la lista ordenada
      WITH commune, collect(name) AS projects
      RETURN commune, projects
      // Ordena por comuna
      ORDER BY commune

  - input: top 3 comunas con más proyectos
  - output: |
      // Top 3 comunas por número de proyectos
      MATCH (p:Project)-[:IN_COMMUNE]->(c:Commune)
      RETURN c.name AS commune, count(DISTINCT p) AS projects
      // Ordena de mayor a menor y corta a 3
      ORDER BY projects DESC, commune
      LIMIT 3

  - input: proyectos con subtype 'anexes' y DocumentType 'ei-document'
  - output: |
      // Intersección: subtipo 'anexes' y DocumentType 'ei-document'
      MATCH (p:Project)-[:HAS_DOCUMENT_SUBTYPE]->(:DocumentSubtype {name:'anexes'})
      MATCH (p)-[:HAS_DOCUMENT_TYPE]->(:DocumentType {name:'ei-document'})
      // Devuelve proyectos únicos
      RETURN DISTINCT p.name AS project
      // Ordena por nombre
      ORDER BY project

  - input: normalizar regiones y agrupar (quitando 'Región de ')
  - output: |
      // Normaliza nombre de región quitando prefijo 'Región de '
      MATCH (p:Project)-[:IN_REGION]->(r:Region)
      WITH CASE WHEN r.name STARTS WITH 'Región de ' THEN replace(r.name,'Región de ','') ELSE r.name END AS regionNormalized, p
      RETURN regionNormalized AS region, count(DISTINCT p) AS projects
      // Ordena por región normalizada
      ORDER BY region

  - input: paginación de proyectos (página 1, tamaño 5)
  - output: |
      // Devuelve proyectos paginados (página 1 tamaño 5)
      MATCH (p:Project)
      RETURN DISTINCT p.name AS project
      // Orden requerido antes de SKIP/LIMIT para resultados deterministas
      ORDER BY project
      SKIP 0
      LIMIT 5

  - input: proyectos con más de una región
  - output: |
      // Proyectos presentes en más de una región
      MATCH (p:Project)-[:IN_REGION]->(r:Region)
      WITH p, count(DISTINCT r) AS regions
      WHERE regions > 1
      RETURN p.name AS project, regions
      // Ordena por mayor número de regiones y luego por nombre
      ORDER BY regions DESC, project

  - input: proyectos con '220 kV' en el nombre (regex)
  - output: |
      // Búsqueda por regex en el nombre del proyecto
      MATCH (p:Project)
      WHERE p.name =~ '.*220 kV.*'
      // Devuelve proyectos únicos
      RETURN DISTINCT p.name AS project
      // Ordena por nombre
      ORDER BY project

  - input: lista de comunas por proyecto (pattern comprehension)
  - output: |
      // Devuelve por proyecto la lista de comunas usando pattern comprehension
      MATCH (p:Project)
      RETURN p.name AS project, [(p)-[:IN_COMMUNE]->(c:Commune) | c.name] AS communes
      // Ordena por nombre de proyecto y limita resultados
      ORDER BY project
      LIMIT 10

  - input: conteo de tipologías por comuna
  - output: |
      // Por comuna: cuenta proyectos y cantidad de tipologías distintas (si existen)
      MATCH (p:Project)-[:IN_COMMUNE]->(c:Commune)
      OPTIONAL MATCH (p)-[:HAS_TIPOLOGIA]->(t:Tipologia)
      RETURN c.name AS commune, count(DISTINCT p) AS projects, count(DISTINCT t) AS tipologias
      // Ordena por proyectos desc y luego por comuna
      ORDER BY projects DESC, commune

  - input: proyectos por año y mes (conteo)
  - output: |
      // Conteo de proyectos por año y mes
      MATCH (p:Project)-[:PRESENTED_ON]->(d:PresentationDate)
      // Normaliza fecha y lleva p para contar
      WITH date(d.date) AS dd, p
      // Devuelve año, mes y número de proyectos únicos
      RETURN dd.year AS year, dd.month AS month, count(DISTINCT p) AS projects
      // Orden cronológico
      ORDER BY year, month

  - input: último proyecto por región (subconsulta)
  - output: |
      // Para cada región, obtiene el proyecto más reciente mediante subconsulta
      MATCH (r:Region)
      CALL {
        WITH r
        // En la subconsulta: proyectos de la región r
        MATCH (p:Project)-[:IN_REGION]->(r)
        MATCH (p)-[:PRESENTED_ON]->(d:PresentationDate)
        // Calcula la última fecha de presentación por proyecto
        WITH p, max(date(d.date)) AS lastDate
        // Ordena de más reciente a más antiguo y toma el primero
        ORDER BY lastDate DESC
        RETURN p.name AS project, lastDate AS date
        LIMIT 1
      }
      // Devuelve región y su proyecto más reciente
      RETURN r.name AS region, project, date
      // Ordena por región
      ORDER BY region

  - input: Proyectos por comuna en la Región de Valparaíso
  - output: |
      /* nombres de los proyectos de Región de Valparaíso por cada comuna */

      MATCH (p:Project)-[IN_REGION]->(r:Region {name: 'Región de Valparaíso'})
      MATCH (p)-[IN_COMMUNE]->(c:Commune)
      RETURN p.name AS proyecto, c.name AS comuna

  - input: Proyectos por comuna en la Región de Los Lagos
  - output: |
      /* nombres de los proyectos de Región de Los Lagos por cada comuna */

      MATCH (p:Project)-[IN_REGION]->(r:Region {name: 'Región de Los Lagos'})
      MATCH (p)-[IN_COMMUNE]->(c:Commune)
      RETURN c.name AS comuna, collect(p.name) AS proyectos

  - input: Proyectos por comuna en la Región de Región del Libertador General Bernardo O'Higgins
  - output: |
      /* nombres de los proyectos de Región del Libertador General Bernardo O'Higgins por cada comuna */

      MATCH (p:Project)-[:IN_REGION]->(r:Region {name: "Región del Libertador General Bernardo O'Higgins"})
      MATCH (p)-[:IN_COMMUNE]->(c:Commune)
      RETURN p.name AS project_name, c.name AS commune_name

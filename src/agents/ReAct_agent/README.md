# ReAct Agent

## Overview

The ReAct (Reasoning and Acting) agent is a LangGraph-based agent that executes plans generated by the planner agent. It follows a ReAct pattern where it reasons about what to do and then acts by calling the appropriate tools.

## Architecture

### Components

1. **State Management** (`schemas.py`)
   - `ReActState`: Manages the agent's state including the plan, current step, tool results, and final answer
   - `ToolResult`: Tracks results from tool executions

2. **Agent Logic** (`agent_logic.py`)
   - `check_plan`: Determines if there's a direct response or steps to execute
   - `execute_step`: Executes the current step using the appropriate tool
   - `reflect`: Reflects on execution and decides the next action
   - `finish`: Compiles results and prepares the final answer

3. **Graph Builder** (`graph_builder.py`)
   - Constructs the LangGraph workflow
   - Defines the control flow between nodes

## Tools

The ReAct agent uses three main tools:

1. **cypher_query_agent**: For querying metadata from the Neo4j knowledge graph
2. **hybrid_graphRAG_agent**: For hybrid graph RAG queries that involve content retrieval
3. **reasoning_agent**: For intellectual tasks like summarizing, analyzing, and interpreting results

## Usage

### Basic Usage

```python
from src.agents.ReAct_agent import graph
from src.agents.planner_agent.schemas import Plan, Step

# Create a plan
plan = Plan(
    goal="Find information about projects",
    steps=[
        Step(
            instruction="Query projects in region",
            suggested_tool="cypher_query_agent",
            reasoning="Use metadata query",
            result="",
            is_complete=False
        )
    ],
    direct_response_to_the_user=""
)

# Execute the plan
async for chunk in graph.astream(
    {"plan": plan},
    stream_mode="updates",
    debug=True
):
    # Process updates
    pass
```

### With Planner Chain

```python
from src.agents.planner_agent.llm_chains import get_planner_chain
from src.agents.ReAct_agent import graph

# Generate a plan
planner = get_planner_chain()
plan = await planner.ainvoke({"input": "Your question here"})

# Execute with ReAct agent
async for chunk in graph.astream(
    {"plan": plan},
    stream_mode="updates"
):
    pass
```

## Testing

Run the tests:

```bash
# Test with hardcoded plans
uv run -m src.agents.ReAct_agent.test_react

# Test with planner integration
uv run -m src.agents.ReAct_agent.graph_builder

# Test reasoning agent integration
uv run -m src.agents.ReAct_agent.test_reasoning_integration
```

## Flow Diagram

```
START
  |
  v
check_plan -> (if direct_response) -> finish
  |
  v (if steps)
execute_step
  |
  v
reflect -> (if more steps) -> execute_step
  |
  v (if done)
finish
  |
  v
END
```

## Error Handling

- The agent gracefully handles unknown tools by defaulting to reasoning_agent
- Errors during step execution are captured and logged
- The agent stops after too many errors (configurable threshold)
- Tool routing is based on keywords in the suggested_tool field:
  - "cypher" or "metadata" → cypher_query_agent
  - "hybrid", "graphrag", or "chunk" → hybrid_graphRAG_agent
  - "reasoning", "reason", or "think" → reasoning_agent
  - Unknown tools → reasoning_agent (default)

## Key Features

1. **Asynchronous Execution**: All operations are async for non-blocking execution
2. **Tool Routing**: Automatically routes to the correct tool based on the step's suggested_tool
3. **Error Recovery**: Continues execution even if individual steps fail
4. **Result Compilation**: Aggregates results from all steps into a coherent final answer
5. **Direct Response Support**: Can return immediate answers without executing steps
